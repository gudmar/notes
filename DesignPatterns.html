<!DOCTYPE html>
<!-- <div>Icons made by <a href="https://www.flaticon.com/authors/pixel-perfect" title="Pixel perfect">Pixel perfect</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a></div> -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" type="image/svg+xml;base64" href="data:image/svg+xml;base64,PHN2ZyBpZD0icmVndWxhciIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjQgMjQiIGhlaWdodD0iNTEyIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3QgeD0iMCIgeT0iMCIgaGVpZ2h0PSI1MTUiIHdpZHRoPSI1MTIiIGZpbGw9InJlZCIgIHN0eWxlPSJmaWxsOnJnYigyNTUsMCwwKTtzdHJva2U6cmdiKDI1NSwyNTUsMjU1KTtzdHJva2Utd2lkdGg6MiIvPiA8cGF0aCBkPSJtMTkgMTJjMCAyLjE2LS45OCA0LjE2LTIuNjcgNS41LS42OS41NC0xLjE0IDEuMjUtMS4yOCAyLjAxLS4wMi0uMDEtLjAzLS4wMS0uMDUtLjAxaC02Yy0uMDIgMC0uMDUgMC0uMDcuMDEtLjE0LS43OS0uNTUtMS40OC0xLjE0LTEuOTItMi4xOC0xLjY1LTMuMi00LjM1LTIuNjQtNy4wNy41NS0yLjY1IDIuNy00LjgxIDUuMzUtNS4zNiAyLjExLS40NSA0LjI3LjA3IDUuOTEgMS40IDEuNjUgMS4zNCAyLjU5IDMuMzIgMi41OSA1LjQ0eiIgZmlsbD0iI2ZmYzEwNyIvPjxwYXRoIGQ9Im0xNS4wNSAxOS41MWMtLjAzLjE3LS4wNS4zNC0uMDUuNTJ2Mi4yMmMwIC45Ni0uNzkgMS43NS0xLjc1IDEuNzVoLTIuNWMtLjg0IDAtMS43NS0uNjQtMS43NS0yLjA0di0xLjc3YzAtLjIzLS4wMi0uNDYtLjA3LS42OC4wMi0uMDEuMDUtLjAxLjA3LS4wMWg2Yy4wMiAwIC4wMyAwIC4wNS4wMXoiIGZpbGw9IiM2MDdkOGIiLz48cGF0aCBkPSJtMTQuMjUgMjFoLTQuNWMtLjQxNCAwLS43NS0uMzM2LS43NS0uNzVzLjMzNi0uNzUuNzUtLjc1aDQuNWMuNDE0IDAgLjc1LjMzNi43NS43NXMtLjMzNi43NS0uNzUuNzV6Ii8+PHBhdGggZD0ibTEyIDMuNDU3Yy0uNDE0IDAtLjc1LS4zMzYtLjc1LS43NXYtMS45NTdjMC0uNDE0LjMzNi0uNzUuNzUtLjc1cy43NS4zMzYuNzUuNzV2MS45NTdjMCAuNDE0LS4zMzYuNzUtLjc1Ljc1eiIvPjxwYXRoIGQ9Im0xOC41NzEgNi4xNzljLS4xOTIgMC0uMzg0LS4wNzMtLjUzLS4yMi0uMjkzLS4yOTMtLjI5My0uNzY4IDAtMS4wNjFsMS4zODQtMS4zODRjLjI5My0uMjkzLjc2OC0uMjkzIDEuMDYxIDBzLjI5My43NjggMCAxLjA2MWwtMS4zODQgMS4zODRjLS4xNDcuMTQ2LS4zMzkuMjItLjUzMS4yMnoiLz48cGF0aCBkPSJtMjMuMjUgMTIuNzVoLTEuOTU3Yy0uNDE0IDAtLjc1LS4zMzYtLjc1LS43NXMuMzM2LS43NS43NS0uNzVoMS45NTdjLjQxNCAwIC43NS4zMzYuNzUuNzVzLS4zMzYuNzUtLjc1Ljc1eiIvPjxwYXRoIGQ9Im0xOS45NTUgMjAuNzA1Yy0uMTkyIDAtLjM4NC0uMDczLS41My0uMjJsLTEuMzg0LTEuMzg0Yy0uMjkzLS4yOTMtLjI5My0uNzY4IDAtMS4wNjFzLjc2OC0uMjkzIDEuMDYxIDBsMS4zODQgMS4zODRjLjI5My4yOTMuMjkzLjc2OCAwIDEuMDYxLS4xNDcuMTQ3LS4zMzkuMjItLjUzMS4yMnoiLz48cGF0aCBkPSJtNC4wNDUgMjAuNzA1Yy0uMTkyIDAtLjM4NC0uMDczLS41My0uMjItLjI5My0uMjkzLS4yOTMtLjc2OCAwLTEuMDYxbDEuMzg0LTEuMzg0Yy4yOTMtLjI5My43NjgtLjI5MyAxLjA2MSAwcy4yOTMuNzY4IDAgMS4wNjFsLTEuMzg0IDEuMzg0Yy0uMTQ3LjE0Ny0uMzM5LjIyLS41MzEuMjJ6Ii8+PHBhdGggZD0ibTIuNzA3IDEyLjc1aC0xLjk1N2MtLjQxNCAwLS43NS0uMzM2LS43NS0uNzVzLjMzNi0uNzUuNzUtLjc1aDEuOTU3Yy40MTQgMCAuNzUuMzM2Ljc1Ljc1cy0uMzM2Ljc1LS43NS43NXoiLz48cGF0aCBkPSJtNS40MjkgNi4xNzljLS4xOTIgMC0uMzg0LS4wNzMtLjUzLS4yMmwtMS4zODQtMS4zODRjLS4yOTMtLjI5My0uMjkzLS43NjggMC0xLjA2MXMuNzY4LS4yOTMgMS4wNjEgMGwxLjM4NCAxLjM4NGMuMjkzLjI5My4yOTMuNzY4IDAgMS4wNjEtLjE0OC4xNDYtLjMzOS4yMi0uNTMxLjIyeiIvPjxwYXRoIGQ9Im0xNS43NSAxMi41Yy0uNDE0IDAtLjc1LS4zMzYtLjc1LS43NSAwLTEuNTE3LTEuMjMzLTIuNzUtMi43NS0yLjc1LS40MTQgMC0uNzUtLjMzNi0uNzUtLjc1cy4zMzYtLjc1Ljc1LS43NWMyLjM0MyAwIDQuMjUgMS45MDcgNC4yNSA0LjI1IDAgLjQxNC0uMzM2Ljc1LS43NS43NXoiLz48cGF0aCBkPSJtMTMuMjUgMjRoLTIuNWMtLjg0MyAwLTEuNzUtLjY0LTEuNzUtMi4wNDR2LTEuNzY0YzAtMS4wNjEtLjQ1Mi0yLjAzNS0xLjIwOS0yLjYwNS0yLjE4NS0xLjY0NS0zLjE5Ni00LjM1MS0yLjYzOS03LjA2Mi41NDUtMi42NTYgMi42OTQtNC44MTMgNS4zNDctNS4zNjggMi4xMS0uNDQ0IDQuMjY4LjA3IDUuOTE0IDEuNDA4IDEuNjQ0IDEuMzM2IDIuNTg3IDMuMzE3IDIuNTg3IDUuNDM1IDAgMi4xNTgtLjk3NSA0LjE2MS0yLjY3NSA1LjQ5OC0uODQyLjY2Mi0xLjMyNSAxLjU4NC0xLjMyNSAyLjUyOXYyLjIyM2MwIC45NjUtLjc4NSAxLjc1LTEuNzUgMS43NXptLTEuMjY0LTE3LjQ5OGMtLjM5MiAwLS43ODcuMDQxLTEuMTgyLjEyMy0yLjA3Ni40MzQtMy43NTcgMi4xMjItNC4xODQgNC4yMDEtLjQzOSAyLjEzNy4zNTUgNC4yNjkgMi4wNzIgNS41NjIgMS4xMzEuODUyIDEuODA3IDIuMjc0IDEuODA3IDMuODA0djEuNzY0YzAgLjA5MS4wMTIuNTQ0LjI1LjU0NGgyLjVjLjEzOCAwIC4yNS0uMTEyLjI1LS4yNXYtMi4yMjNjMC0xLjQwOS42OTItMi43NiAxLjg5OC0zLjcwOSAxLjMzNy0xLjA1IDIuMTAzLTIuNjI0IDIuMTAzLTQuMzE4IDAtMS42NjQtLjc0Mi0zLjIyMS0yLjAzNC00LjI3MS0uOTg4LS44MDItMi4yMTMtMS4yMjctMy40OC0xLjIyN3oiLz48L3N2Zz4=">
    <title>Design patterns</title>
    <style>
            *{
                font-family: Arial, Helvetica, sans-serif;
            }
            td{
                text-align: center;
                vertical-align: middle;
                border: solid thin black;
                padding: 1rem;
            }
            td:nth-child(3){
                text-align: left;
            }
            table{
                border-collapse: collapse;
            }
            .table{
                max-width: 500px;
                position: relative;
            }
            .uml td{
                text-align: left;
            }
            .uml ul{
                list-style-type: none;
                text-align: left;
            }
            .uml th {
                border: solid black thin;
                text-align: center;
            }
            code{
                background-color: black;
                color: lightgray;
                padding: 5px;
                border-radius: 5px;
            }
            p{
                line-height: 1.75rem;
            }
            li{
                line-height: 1.75rem;
            }
            a{
                text-decoration: none;
                cursor: pointer;
            }
            .button{
                display: flex;
                justify-content: center;
                align-content: center;
                align-items: center;
                padding: 5px;
                border: solid black thin;
                border-radius: 5px;
                transition: 0.3s;
                position: relative;
                max-width: 90px;
            }
            .button-hide {
                width: 20px;
                height: 20px;
                padding: 2px;
            }
            .button:hover{
                background-color: gray;
                color: white;
                transition: 0.3s;
                cursor: pointer;
            }
            .pointer:hover{
                cursor: pointer;
                background-color: lightgray;
            }
            .title {
                display: flex;
                margin-top: 60px;
                margin-bottom: 15px;
            }
            .title > * {
                margin: 0;
                margin-right: 20px;
            }
            .hidable{
                border: solid thick black;
                border-left: none;
                border-right: none;
                border-radius: 0.5rem;
                margin: 1rem;
                padding: 1rem;
                max-width: 1200px;
                margin-left: auto;
                margin-right: auto;
            }
            .hidden{
                position: relative;
                height: 0;
                transition: 0.3s;
                overflow: hidden;
            }
            .wrapper{
                position: relative;
                max-width: 1200px;
                min-width: 600px;
                margin-left: auto;
                margin-right: auto;
            }
            h1 {
                margin-left: auto;
                margin-right: auto;
                font-size: 5rem;
                font-weight: 100;
                text-align: center;
            }
            .note{
                display: inline-block;
                margin: 1rem;
                background-color: gray;
                color: white;
                position: relative;
                padding: 1rem;
                padding-left: 2rem;
            }
            .note>.example{
                color: black;
            }
            .note>.code{
                color: white;
            }
            .note:before{
                content: '!';
                position: absolute;
                top: 1rem;
                left: 1rem;
                font-weight: bold;
                font-size: 1.5rem;
            }
            .explanation{
                margin: 1rem;
                padding: 1rem;
                background: rgb(180, 220, 180);
            }
            .example{
                margin: 1rem;
                padding: 1rem;
                background: rgb(220, 220, 220);
                overflow: auto;
            }
            .example>pre{
                font-family: 'Courier New', Courier, monospace;
            }

        </style>
        <script src="index.js"></script>
</head>
<body>
<div class="wrapper">
    <h1 id = "home"><a href ="https://www.dofactory.com/javascript/design-patterns">Patterns</a></h1>
    <div class="content">
        <h3>Structural patterns</h3>
        <ul>
            <li class="pointer"><a href="#adapter"><b>Adapter</b></a></li>
            <li class="pointer"><a href="#bridge"><b>Bridge</b></a></li>
            <li class="pointer"><a href="#composite"><b>Composite</b></a></li>
            <li class="pointer"><a href="#decorator"><b>Decorator</b></a></li>
            <li class="pointer"><a href="#facade"><b>Facade</b></a></li>
            <li class="pointer"><a href="#flyweight"><b>FlyWeight</b></a></li>
            <li class="pointer"><a href="#proxy"><b>Proxy</b></a></li>
        </ul>
        <h3>Creational patterns</h3>
        <ul>
            <li class="pointer"><a href="#abstract"><b>Abstract factory</b></a></li>
            <li class="pointer"><a href="#builder"><b>Builder</b></a></li>
            <li class="pointer"><a href="#factroy"><b>Factory</b></a></li>
            <li class="pointer"><a href="#prototype"><b>Prototype</b></a></li>
            <li class="pointer"><a href="#singleton"><b>Singleton</b></a></li>
        </ul>

        <h3>Behavioral</h3>
        <ul>
            <li class="pointer"><a href="#chain"><b>Chain of responsibilities</b></a></li>
            <li class="pointer"><a href="#command"><b>Command</b></a></li>
            <li class="pointer"><a href="#interpreter"><b>Interpreter</b></a></li>
            <li class="pointer"><a href="#iterator"><b>Iterator</b></a></li>
            <li class="pointer"><a href="#mediator"><b>Mediator</b></a></li>
            <li class="pointer"><a href="#memento"><b>Memento</b></a></li>
            <li class="pointer"><a href="#observer"><b>Observer</b></a></li>
            <li class="pointer"><a href="#state"><b>State</b></a></li>
            <li class="pointer"><a href="#strategy"><b>Strategy</b></a></li>
            <li class="pointer"><a href="#template"><b>Template</b></a></li>
            <li class="pointer"><a href="#visitor"><b>Visitor</b></a></li>
        </ul>
        <h3><a href = "#dictionary"> Dictionary</a></h3>
        <h3><a href="#uml">UML</a></h3>
        <ul>
            <li class="pointer"><a href="">Packed diagram</a></li>
            <li class="pointer"><a href="">Use case diagram</a></li>
            <li class="pointer"><a href="">Activity diagram</a></li>
            <li class="pointer"><a href="">Sequence diagram</a></li>
            <li class="pointer"><a href="">Component diagram</a></li>
            <li class="pointer"><a href="#classDiagram">Class diagram</a></li>
        </ul>
        <ul>
            <li class="pointer"><a href="#commonErrors"><b>Comon errors</b></a></li>
        </ul>
    </div>

    <div class="hidable-wrapper">
        <div class="title"><div class="button button-hide">+</div><h2 id = "creational">Creational patterns</h2></div>
        <div class="hidable" name = "creational">

            <div class="hidable-wrapper">
                <div class="title"><div class="button button-hide">+</div><h3 id = "abstract">Abstract factory</h3><a href="#home"><div class="button">Home</div></a></div>
                <div class="hidable" name = "abstract">
                        <p>A factory is a function that creates objects. There are 2 factories. One produces light buttons, and other one produces buttons for dark themes. A abstract factory
                            would concatenate those factories into one, producing both.
                        </p>
                        <div class="example">
                        <pre>
    class LightButtonFactory {
        constructor(){
            this.id = Math.random().toString(36).substr(2, 9);
        }
        create(type){
            switch (type) {
                case 'button':
                    return this.lightButton();
                    break; // unnecessarry, return breaks this loop anyway
                case 'switch':
                    return this.lightSwitch();
                    break; // unnecessarry, return breaks this loop anyway
                case 'checkbox':
                    return this.lightCheckbox();
            }
        }
    }    

    class DarkButtonFactory {
        constructor(){
            this.id = Math.random().toString(36).substr(2, 9);
        }
        create(type){
            switch (type) {
                case 'button':
                    return this.darkButton();
                    // break;// unnecessarry, return breaks this loop anyway
                case 'switch':
                    return this.darkSwitch();
                    break; // unnecessarry, return breaks this loop anyway
                case 'checkbox':
                    return this.darkCheckbox();
            }
        }
    }    

    class ButtonFactory { // abstract
        constructor(){
            this.darkButtonFactory = new DarkButtonFactory();
            this.lightButtonFactory = new LightButtonFactory();
        }
        create(theme, type){
            switch(theme) {
                case 'dark':
                    return this.darkButtonFactory.create(type);
                case 'light':
                    return this.lightButtonFactory.create(type);

            }
        }
    }
                        </pre>
                    </div>
                <h4>My application exercies</h4>
                <p>Hard to think of something. Button example seems ok. Css is responsible for button behavior, however it might depend on classes given to html elements, and this might be hardcoded in factories.</p>
                </div>
            </div>


            <div class="hidable-wrapper">
                <div class="title"><div class="button button-hide">+</div><h3 id = "builder">Builder</h3><a href="#home"><div class="button">Home</div></a></div>
                <div class="hidable" name = "Builder">
                    <p>Allows client to construct complex objects by specifying type and content only. So example would be probably a component</p>
                    <div class="example">
            <pre>
    class MyComponent{
        constructor() {
            this.id = this.getAttribute('id')==undefined?Math.random().toString(36).substr(2, 9):this.getAttribute('id');
            .
            .
            .
            let content = this.getTemplate().cloneNode(true).innerHTML
            this.attachShadow({mode: 'open'}).appendChild(content);
        }
        getTemplate(){
            return `
            &lt;style&gt;
            .
            .
            .
            &lt;/style&gt;
            &lt;div id = ${this.id}...
            `
        }
    }
    window.addEventListener('DOMContentLoaded', (e) => {window.customElements.define('my-component', MyComponent)})
            </pre>
            </div>
                </div>
            </div> <!--hidable-wrapper-->



            <div class="hidable-wrapper">
                <div class="title"><div class="button button-hide">+</div><h3 id = "factory">Factory</h3><a href="#home"><div class="button">Home</div></a></div>
                <div class="hidable" name="Factory">
                    <p>Object used to create objectes. See abstract factory. Can be also implemented with a fucntions. Here - example of fucntion factory</p>
                    <div class="example">
                    <pre>
    function factory(contextVariable){
        let contextMemory = contextVariable; // will be remembered. Can be modified and read by member (returned) functions
        return {
            product1: function(args) {
                return something;
            },
            product2: fucntion(args) {
                return somethingElse;
            }
        }
    }
    let f = factory(situation);
    let p1 = f.product1(args);

                    </pre>
                </div>
                </div>
            </div> <!--hidable-wrapper-->


            <div class="hidable-wrapper">
                <div class="title"><div class="button button-hide">+</div><h3 id = "prototype">Prototype</h3><a href="#home"><div class="button">Home</div></a></div>
                <div class="hidable" name="prototype">
                    <a href="https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b" target = "_blank">Link</a>
                    <div class="note">
                        <ul>
                            <li><b>Instantiance methods</b> are methods that can be called on object creatd from a object template (class). They cannot be called from class itself. Eg:
                                <code>'someString'.localCompare('someString')</code> is a method used on instance of object.
                            </li>
                            <li><b>Static method</b> is a method that can be called only without creating a class instance. Like <code>Object.JSON.stringify(customObject)</code></li>
                            <li>
                                <b>the Object</b> the root element of all objects. This objects parent has a prototype pointitg to null
                            </li>
                            <li><b>template object</b> By this author means a generic class of objects that will be used to create object instances. Object template is used because in js 
                                historicly there was no class keyword and lately objects similar to today classes were created form functions.
                            </li>
                        </ul>
                        <p>JS engine adds a <code>__proto__</code> property to each newly created object. It points to the prototype object of the constructor function:
                        </p>
                        <pre>
---------Object definition---                           --------Prototype object---------
|   prototype-property      |  -------------------->    |                               |
|                           |                           |                               |   
|                           |  &lt;--------------------    |   constructor property        |
-----------------------------                           ---------------------------------
                                                                    ^
-------Instance-------------                                        |
|                          |-----------------------------------------
|   __proto__              |
----------------------------

                        </pre>
                        <p>
                            __proto__ and prototype are pointing to the same object.
                            When property or method in object instance is invoked it is searched for in this object instance first. Then it is searched in prototype. If it is not found it
                            is serached for in all parent prototype objects (inheritance). If property is not found in paretn prototype objects undefined is returned.
                        </p>
                        <p>
                            If a property is added to prototype every change in it made by one of object instances will be visible by all instances of this object.
                        </p>
                    </div>

                    <p>
                        JS is object inheritance based. Innitial <code>Object</code>, after which all other objects inherit, has a prototype. Prototype is also an object that posesses all <b>non static</b> 
                        attirbutes and methods.
                        Each object in inheritance path inherits <code>prototype</code> after a parent and adds its own attributes and methots.</br>
                        <ul>
                            <li>Prototype is a object. Object/class definition points to that object</li>
                            <li>Prototype has a constructor of function/class it belongs to. Each function/class instance has a filed pointing to prototype</li>
                            <li>Prototype is shared among all instances of a object. All methods under prototype are sheared among all instances as well</li>
                            <li>There is also a __proto__ that is added to each object/class instance. This __proto__ points to prototype of this object (it points to the same prototype object that protytype field in object definition)</li> 
                            <li>Prototype is innitially in <code>Object</code> root element. Parent of <i>the Object</i> element prototype points to null</li>
                            <li>A child object inherits prototype after a parent, and adds its own attributes and methods</li>
                            <li>Methods defined in an objects prototype are not copied into child prototype, they stay in parent prototype and if a method is invoked on an object the inheritance chain searches 
                                for this method starting from the owner and then searches all parent prototypes untill a method is found, or untill the inheritance chain reaches root Object. In that case 
                                there is an error.
                            </li>
                            <li>
                                <mark>Beware!</mark> Do not use construction of functions with a <code>new</code> operator, because <b>each of owned methods</b> will be copied into each created this way
                                function instance. Eg:
                                <div class="example">
                                    <pre>
function someFunction(){};
let inst1 = new someFunction();
let inst2 = new someFunction(); // in this case both instances will have copies of all methods owned by someFunction definition.
                                    </pre>
                                </div>
                            </li>
                            <li>Adding a method to prototype means adding a method reusable in all objects instances created with object template. This method will be available in all child object templates as well</li>
                            <li>
                                <mark>prototype methods are available <b>only</b> in object instance, where methods <b>not belonging</b> to prototype are <b>static</b> methods available for the object</mark></br>
                                <i>ex. Object.JSON.stringify() is a static method, where str1.localcompare(str2) is a instance method</i>
                            </li>
                            <li>Ofcourse methods can also be encapsulated in function (class, object template) and not usable from outer. Like a privete method</li>
                        </ul>
                    </p>
                    <div class="example">
                        <h4>Example:</h4>
                        <pre>
class Car{
    constructor(id){
        this.id = id;
    }
}                    
Car.prototype.setMade = function(name) {this.name = name}
let c1 = new Car(1);
let c2 = new Car(2);
Car.prototype.setMade('Subaru');
let c2.setMade('Peugeot');

console.log(Car.name) // Subaru
console.log(c2.name) // Peugeot -> as name of this instance was defined
console.log(c1.name) // Subaru -> as c1 name was not defined it is taken from its prototype
                        </pre>
                        <h4>Example:</h4>
            <pre>
    function Person(name, surname){
        this.name = name;
        this.surname = surname;
        function getSecondName() {console.log(this.surname);}  // internal, not visible form outer scope
        return {
            getShueSize() {console.log('35')}
        }
    }
    Person.getPersonName = function() { console.log(this.name);}

    Person.prototype = {getSurname: function() {console.log(this.surname)} }
    Person.prototype = {getMiddleName: function() {console.log('Not defined middle name')} }
        // BEWARE !!! THIS overwrittes all prototype methods. !!! Better Person.prototype.getMiddleName(){}  !!!

    Person.prototype.getHeight = function() {    // THIS really adds a method to prototype...
        console.log('my height is 189')
                }
            </pre>          
                <div class="explanation">
                    <ul>
                        <li><code>getSecondName()</code> is private and visible only inside Person object template</li>
                        <li><code>getShueSize</code> is returned, so it can be used by every instance of Person</li>
                        <li><code>getPersonName()</code> is defined outside template body, but on template. Because it is not defined inside a prototype, it will be a static method.
                            This method will not be visible on instanced objects.
                        </li>
                        <li><code>getSurname()</code> will not be available at all, because it is overwritten in next line. In this case whole Person.prototype is being set!</li>
                        <li><code>getMiddleName(), getHeight()</code> are visible in all instances of Person declared <mark>after</mark> adding this functions to Person</li>
                        <li><code>getHeight()</code> will not override whole prototype object. This is a proper way to add something to a prototype</li>

                    </ul>
                </div>
                <h4>Example with classes:</h4>
            <pre>
    class Person {
        constructor(name, surname){
            this.name = name;
            this.surname = surname;
        }
        
        getShueSize = function() {console.log(35)} // instantiace method
    }
    // Peroon.getSurname() {} // Illegal will cause syntax error
    Person.getPerosnName = function() { console.log(this.name)}  // a static method
    Person.prototype.getSurname = function() {console.log(this.surname)} // instantiace method - on prototype
    let antoni = new Person('Antoni', "Dupa")
            </pre>    
            <div class="explanation">
                <ul>
                    <li><code>getShueSize()</code> is a instantiance method. Only on instance of class.</li>
                    <li><code>Person.getSurname() {}</code> outside class body. Illegal, will cause syntax error. Use <code>Person.getSurname = function(){}</code> instead.</li>
                    <li><code>Person.getPersonName = function() {}</code> a static method. Only on class, never on instance.</li>
                    <li><code>Person.prototype.getSurname = function() {}</code> instantiance method, because defined on prototype.</li>
                </ul>
            </div>
            <h3>List of class instances</h3>
            <pre>
    class Person {
        constructor(name, surname){
            // Person.instance = this;
            if (!Person.instance){
                Person.instance = [];
            }
                Person.instance.push(this)

            this.name = name;
            this.surname = surname;
        }
        getShueSize = function() {console.log(35)} // instantiace method
    }
            </pre>
            <div class="explanation">
                Person.instance will be a static field, that will hold information about all instances of Person ever created.
            </div>
                </div>  <!--example-->  

                <div class="note">
                    There is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target:'_blank'><code>Object.defineProperty(objName, propName, descritpion)</code></a>
                    method available. It can be used to have more control under defined property. Descritpion is a object with below fields (all fields are by default false or undefined):
                    <ul>
                        <li><code>configurable</code>: if true type of filed will be mutable</li>
                        <li><code>enumerable</code>: if true then this property will show up during enumeration of properties</li>
                        <li><code>value</code>: a value associated with objects property</li>
                        <li><code>writable</code>: indicates if objects value is mutable</li>
                        <li><code>get</code>: define a getter</li>
                        <li><code>set</code>: define a setter</li>
                    </ul>
                </div>

                </div>
            </div> <!--hidable-wrapper-->


            <div class="hidable-wrapper">
                <div class="title"><div class="button button-hide">+</div><h3 id = "singleton"><a href="https://stackoverflow.com/questions/1479319/simplest-cleanest-way-to-implement-singleton-in-javascript">Singleton</a></h3><a href="#home"><div class="button">Home</div></a></div>
                <div class="hidable" name="singleton">
                    <p>Singleton is a class, that may have only one instance in whole application. Example would be a <i>mediator</i> class, that managed objects (see <a href="#mediator")>mediator</a>).</p>
                    <div class="example">
                        <h3>Example</h3>
                <pre>
    class Singleton {
        constructor () {
            if (!Singleton.instance) {
            Singleton.instance = this
            }
            // Initialize object
            return Singleton.instance
        }    
    }
        const instance = new Singleton()
        Object.freeze(instance)
        
        export default instance
                </pre>        
                    <div class="explanation">
                        <ul>
                            <li>Nativly there is no such a thing as Object.instance, however it can be added to Obejct</li>
                            <li>constructor may return an instance of this in case a return statement is present</li>
                            <li><code>freeze()</code> not needed here, but this prevents an instance from being modified</li>
                        </ul>
                    </div>
                    <h4>In ES5 this would look like this:</h4>
                <pre>
    var Singleton = function() {
        "use strict";
        if (Singleton.instance) {
            // Singleton already exists, so code related to this situation
            return Singleton.instance;
        } // else not necessary because of return
        Singleton.instance = this;
    };
    Singleton.getInstance = function() {
        "use strict";
        return Singleton.instance || new Singleton;
    }
                </pre>
                <div class="explanation">
                    <a href="https://stackoverflow.com/questions/1479319/simplest-cleanest-way-to-implement-singleton-in-javascript">
                        There was another sollution to the problem with wrapping functin in IIFE, but that was called rather a <b>module pattern</b>
                    </a> 
                </div>
                <h4><a href = "https://medium.com/@tomanagle/software-design-patterns-in-javascript-7b329e14aa48"> sollution IIFE</a></h4>
                <pre>
    let singleton = (function() {
        "use strict"
        let memory = 0;
        return {
        get: function() {return this.memory},
        set: function(c) {this.memory = c;}
        }
    })()
    let s1 = singleton;
    s1.set(4)
    let s2 = singleton;
    s2 = singleton;
    s2.set(5)
    console.log(s1.get())
    console.log(s2.get())
    // This also acts like a singleton, as IIFE is executed once and the result is passed to singleton variable.
    No possibility to execute this IIFE again
                </pre>
                </div>

                </div> <!--hidable-->
            </div> <!--hidable-wrapper-->

        </div> <!--hidable  creational-->
    </div> <!--hidable-wrapper-->



    <div class="hidable-wrapper">
        <div class="title"><div class="button button-hide">+</div><h2 id = "structural">Structural patterns</h2></div>
        <div class="hidable" name = "structural">

        
        <div class="hidable-wrapper">
            <div class="title"><div class="button button-hide">+</div><h3 id = "decorator">Decorator</h3><a href="#home"><div class="button">Home</div></a></div>
            <div class="hidable">
<a href="https://www.telerik.com/blogs/decorators-in-javascript" target="_blank">Link</a>
                <p>Decorator is a function taking an object and adding extre functionalities to it without modifying it.</p>
                <div class="example">
        <pre>
const Person = function(name, data) {
    this.name = name;
    this.data = data;
    this.greet = function() {
    return console.log(`Hi! my name is ${this.name}`);
    };
};

data = {
    shueSize : '34',
    schoolsFinished: {
        basicSchool: 'im. dzieci głogowskich',
        highSchool: 'im. Bolesława Krzywoustego',
        collage: 'Politechnika Wrocławska'
    },
    favoriteNumbers: [23, 43, 55, 23]
}

// Create a decorator that gives the Persn object some extra functionality
const DecoratedPerson = function(person, email) {
    for (let item in person){
    this[item] = person[item]
    }
    
    this.person = person;
    this.email = email;

    this.whatsYourEmail = function() {
    return console.log(`My email address is ${this.email}.`);
    };
};
DecoratedPerson.prototype.getData = function() {console.dir(this.data)}
// Initalise the first instance of the Person object
const peter = new Person('Peter', data);

peter.greet();

// Create a new object that wrapps the Person in the extra functionality
const decoratedPeter = new DecoratedPerson(peter, 'text@example.com');
decoratedPeter.greet();
decoratedPeter.whatsYourEmail();
decoratedPeter.getData();
        </pre>

                <div class="explanation">
                        This sollution whould coppy even deeply nested objects inside 
                </div>
            </div>
            </div>
        </div> <!--hidable-wrapper-->

        <div class="hidable-wrapper">
            <div class="title"><div class="button button-hide">+</div><h3 id = "decorator"><a href = ""> Decorator pattern</a></h3><a href="#home"><div class="button">Home</div></a></div>
            <div class="hidable" name = "Decorator">
                <a href="https://www.telerik.com/blogs/decorators-in-javascript" target="_blank">Link</a>
                <p>A decorator is a wrapping function, that is adding some new functionality to a existing:</p>
                <ul>
                    <li>Class definitions</li>
                    <li>Properties</li>
                    <li>Methods</li>
                    <li>Accessors (setters and getters</li>
                    <li>Parameters</li>
                </ul>
                <p>Decorator by definition returns a function and takes a <b>target</b>, <b>name</b> and a <b>descriptor</b> as properties.</p>
                <p>This is usefull if for instance:</p>
                <ul>
                    <li>There is a need to rerender a component if its state is changed (decoreate a setter)</li>
                    <li>Hendle some exeptions</li>
                    <li>Show a confirmation window before operation</li>
                    <li>Log something</li>
                    <li>...</li>
                </ul>
                <p>Be carefull. In case of inheritance: inheriting object will not inherit a decorator.</p>
                <h4>Property descriptors</h4>
                <p>
                    One of arguemnts passed with a function decorator in JS is property descriptor. This is a object that can be read with <code>Object.getOwnPropertyDescriptor(myObj, 'propName')</code>
                    and can be set with <code>Object.defineProperty(myObj, propName, descriptorObject)</code>. This descriptorObject, that is retrurned by getOwnPropertyDescriptor and set by defineProperty
                    is defined:
                    <ul>
                        <li><b>value</b>: property value</li>
                        <li><b>wirtable:</b> if value of property will be changable</li>
                        <li><b>enumerable</b>: if this property will show during enumeration</li>
                        <li><b>configurable</b>: if type of this property will be allowed to change</li>
                        <li>In addition defineProperty allows to redefine setter and getter (set, get property</li>
                    </ul>
                    <p>All above properties are by default set to false or undefined</p>
                </p>

                <h4>2020: decorators are still not supported in JS. Need to use angular, typescript or fiddle.js</h4>
                <p>However it can be done, because TS compiles to JS, and TS supports decorators</p>
                <div class="example">
<pre>
    class ObjectManipulator {
        constructor(object){
            this.object = object;
        }
        confirmation(){ // This one is not a decorator. Just a method working like o.confirmation().printObject();
            let allow = confirm('are you sure?'); // This is not async!! however works like async await
            if (allow) {
                console.log('Confirmed')
                return this;
            } else {
                console.log('NOt confirmed')
                return null;
            }
            
        }
        
        confirmDecorator(method, args){ // this is a decorator. Must be implemented in class here and invoked later when class is used
            let allow = confirm('Are You sure?');
            if (allow) {
            // let result = eval('this.' + method).apply(this, args)
            let result = this[method].apply(this, args)
            return result
            } else {
            return null;
            }
        }
        printObject(){
            console.dir(this.object)
        }
        addToObject(propName, val){
            Object.defineProperty(this.object, propName, {
            value: val,
            enumerable: true
            })
        }
        deleteFromObject(propName){
            delete this.object.propName;
        }
        }
        let o1 = new ObjectManipulator({
        a: 'aProp',
        b: 'bProp'
        })
        // o1.confirmation().printObject();
        o1.confirmDecorator('printObject');
</pre>                    
                </div>
                <h4>TypeScript:</h4>
                
                <p>Decorator in TS is denoted with <code>@MethodName(param)</code>. Parameter is passed in case decorator is a factory. Each decorater takes 3 parameters (denoted in definition, not in invocation)</p>
                <ul>
                    <li>object: reference to object that is a target of decoration</li>
                    <li><b>key</b>: key of an object that is the target of decorator</li>
                    <li><b>descirptor</b>: descriptor property of object being the target of decorator. Descirptor is, as desciribed above:
                        <ul>
                            <li>enumerable</li>
                            <li>wirtable</li>
                            <li>configurable</li>
                            <li>value</li>
                        </ul>
                    </li>
                </ul>


                <div class="example">
<pre>
        function Confirmable(message: string) {
            return (target: Object, key: string | symbol, descritpor: PropertyDescritpor) {
                const original = descriptor.value;
    
                descriptor.value = function( ...args: any[]) { // not an arrow
                    const allow = confirm(message);
    
                        if (allow) {
                            const result = original.apply(this, args);
                            return result;
                        }   else {
                            return null;
                        }
                    }
                }
    
                return descriptor;
            };
        }
        class Something {
            constructor();
            @Confirmable('Are You sure You want to do this?')
            @Comfirmable('Are You realy sure You want to do this?')
            someOperation() {};
        }
</pre>                    
                </div>


            </div> <!--hidable-->
        </div><!--hidable-wrapper-->        

        <div class="hidable-wrapper">
            <div class="title"><div class="button button-hide">+</div><h3 id = "bridge"><a href = "https://codepen.io/kalishuck/pen/bpLmQE"> Bridge</a></h3><a href="#home"><div class="button">Home</div></a></div>
            <div class="hidable" name = "Bridge">
        <p>Purpose of this pattern is to separate implementation from abstract layer interfevce.</p>
        <p>Examples would be:
        </p>
        <ul>
            <li>Shape as an abstract layer, and color class, and triangle, rectangle, circle classes. Concrete implementation would be a blue circle</li>
            <li>A script drawing a shape, where implementation would be Canvas or SVG</li>
        </ul>
        <div class="example">
            <pre>
var impl;
impl = new ImplSvg('svg');
impl = new ImplCanvas('canvas') ;

// create technology agnostic paper, but inject choosen technology
var paper = new Paper(impl);
paper.rectangle(10, 10, 100, 100);
paper.triangle(25, 25, 100, 100);

// ----------------------------------
// BRIDGE PATTERN IMPLEMENTATION
// ----------------------------------

// Draws different shapes in technology agnostic way.
function Paper(impl) {
return {
    rectangle: function(x1, y1, x2, y2) {
    impl.line(x1, y1, x1, y2)
    impl.line(x1, y2, x2, y2)
    impl.line(x2, y2, x2, y1)
    impl.line(x2, y1, x1, y1)
    },

    triangle: function(x1, y1, w, h) {
    impl.line(x1, y1, x1, y1 + w)
    impl.line(x1, y1, x1 + h, y1)
    impl.line(x1 + h, y1, x1, y1 + w)
    }
}
}

// Specific technology implmentors
// Implements line(x1,y1,x2,y2) method using related technology
// (Canvas or SVG or ...)

// Canvas Implementor
function ImplCanvas(id) {
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
ctx.scale(1, 1);

return {

    line: function(x1, y1, x2, y2) {

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    }
}
}

// SVG Implementor
function ImplSvg(id) {

var svg = $("#" + id);
var ns = "http://www.w3.org/2000/svg";

return {
    line: function(x1, y1, x2, y2) {
    var line = document.createElementNS(ns, "line");
    line.setAttributeNS(null, "x1", x1);
    line.setAttributeNS(null, "y1", y1);
    line.setAttributeNS(null, "x2", x2);
    line.setAttributeNS(null, "y2", y2);
    svg.append(line)
    }
}
}
            </pre>
            <div class="explanation">
                <ul>
                    <li>
                        <code> impl = new ImplSvg('svg') </code> - chosing a implementation
                    </li>
                    <li>
                        <code>var newPaper(impl)</code> - create something like an abstract layer, though it is instantialized, it is separated from lower layer impl.
                    </li>
                </ul>
            </div>
        </div>
            </div>
        </div><!--hidable-wrapper-->


        <div class="hidable-wrapper">
            <div class="title"><div class="button button-hide">+</div><h3 id = "composite"><a href = ""> Composite pattern</a></h3><a href="#home"><div class="button">Home</div></a></div>
            <div class="hidable" name = "Composite">
                <a href="https://refactoring.guru/pl/design-patterns/composite" target="_blank">Link</a>
                <p>Composite is a pattern that helps to manage tree structures, consisting of items and wrappers. It introduces a common interface for both item and wrapper. Client, 
                    a element comunicating with introduced interface, does not know if it is using an interface of item or wrapper. A good example would be folders and files on disc. 
                    Each item can be of a different type. Each item is called a leaf. Each leaf has its own methods (like getSize in folder/file example). Each folder has a similar 
                    mathod. However to calculate folders size, it will ask its children for theri sizes recursivly, summ result and return it.
                </p>
                <h4>Structure</h4>
                <ul>
                    <li><b>Client</b>: this element will be an actor - a component working with interface</li>
                    <li><b>Componenet</b>: an interface given to outside world. Each grahp node (composite or leaf) has exectly the same interface. Interface has public methods for outside world:
                        <ul>
                            <li>Add element</li>
                            <li>Remove element</li>
                            <li>Execute some command on whole tree (like count all node values and summ them)</li>
                        </ul>
                    </li>
                    <li><b>Composite</b>: Each composite is a folder, a node that has children. It also has a common interface - the same client is given</li>
                    <li><b>Leaf</b>: a node with no children. Can be an item of different types. It has common interface. However each leaf can have a different implementation of methods of this interface, as each leaf can be of a different type. Nodes (composites) will only aggregate values returend by leafs</li>
                </ul>
                <div class="example">
                    <h4>Implementation on pseudocode: grahp</h4>
                    <p>Suppose our graph will perform mathematical operations on elements in gorups</p>
                    <pre>
interface graph {
    addElement() {},
    removeElement() {},
    iterate() {}, 
    removeAllElementsEqualTo() {},
    moveElement() {}
}

class Leaf{
    constructor(value)
    setValue(val) // addEventListener here
    getValue()
    toJson();
    formJson(stringJson)
}
class Composite{
    constructor(operator: '+' | '-' | '*' | '/') { this.children:interface@graph = []}
    aggregate() { // perform operation aggregating all children}
    getValue() {a getter, performing aggregation on all child elements}
    addElement(type: composite | leaf) // bridge pattern can be used
    removeElement();
    setOperator(operator: '+', ...) // addEventListener here
    toJson();
    formJson(stingJson)
}

class Client{
    constructor() {} // can be placed on page as custom component. Will add root element
    toJson() // returns json representation of tree
    fromJson(stringJsonRepresentation) // from stringified JSON create tree structure

}

<h4>How to implement:</h4>
<ol>
    <li>Ensure that model can be represented with tree structure: devide into basic elements. Remember that each composite may contain leaf and composites</li>
    <li>Define a interface for cmoonent with list of common methods for both: components and leafs (defining methods for all classes makes it simpler)</li>
    <li>Create a leaf class with methods and thier description</li>
    <li>Create a composite class containing an array field for child components. Remember, that this class will delegate its duties to children</li>
    <li>Define a method allowing to add/remove/move objects</li>
</ol>
<h4>Binding this pattern to other patterns</h4>
<ul>
    <li>Bulider</li>
    <li>Chain of responsibilities: passing commands to child components can be done this way</li>
    <li>Iterators: can be used to traverse tree elements</li>
    <li>Visitor: execute command on whole tree</li>
    <li>flyWeight (pyłki): components or leafs can be implemented this way to save memeory</li>
    <li>Decorator is similar to composite. Decorator just extends only one child elements functionality, where composite aggregates child elements.</li>
</ul>

                    </pre>
                </div>
                <h4>Examples for practice:</h4>
                <ul>
                    <li>Folder - file UI</li>
                    <li>Graphical editor with feature of grouping elements. In this case component would be responsible for drawing shapes. Draw instruction will be passed through it.</li>
                    <li>Calculator: each number would be a leafe, where each operation would be a composite (folder)</li>
                    <li>Graph: drawing a graph of elements on screan. Each node would have some kind of property that could be summed up !! - good for start</li>
                    <li>Grouping elements: extend graph from previous example and practice implementation of grouping elements for graph editor:
                        <ul>
                            <li>Starting point is root container
                                <ul>
                                    <li>adding possible to container</li>
                                    <li>No possibility to add container, only gorupuoing elements allowed</li>
                                </ul>
                            </li>
                            <li>Option of adding element to a container (no poossibolility to add container, only group elements</li>
                            <li>Goruping elements
                                <ul>
                                    <li>Chose container</li>
                                    <li>Then choose elements to be goruped (choosing element with children would cause whole group selection). Reference to choosen elements is stored in temporary table</li>
                                    <li>No possibility to choose target container or its parents. They will not be able to be added to group, as group cannot contain itself</li>
                                    <li>Confirm group creation
                                        <ul>
                                            <li>Each element from choosen elements table is searched for in whole tree starting from root, removed from tree structure</li>
                                            <li>Whole temporary table of choosen elements is added to target element as a group of elements</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Each node has a method of counting summ of its siblings</li>
                            <li></li>
                        </ul>
                    </li>
                </ul>

            </div> <!--hidable-->
        </div><!--hidable-wrapper-->


    </div> <!--hidable-wrapper-->




    <div class="hidable-wrapper">        
        <div class="title"><div class="button button-hide">+</div><h2 id = "behavior">Behavioral patterns</h2><a href="#home"><div class="button">Home</div></a></div>
        <div class="hidable-wrapper">
            <div class="title"><div class="button button-hide">+</div><h3 id = "chain"><a href = "https://medium.com/backticks-tildes/understanding-method-chaining-in-javascript-647a9004bd4f"> Chain</a></h3><a href="#home"><div class="button">Home</div></a></div>
            <div class="hidable" name = "Chain">
                <p>Purpose of chaining pattern is to make code read in the same direction that it is written. Imagine aritmethical expression: (a + b) * c - d</p>
                <div class="note"><p>Chain pattern is a different pattern than chian of responsibilities! Chian even should not be put here but to other cathegory. 
                    For <b>chain of responsibilities</b> please go <a href = '#realChain'>here</a>
                </p></div>
                <div class="example">
                    <h4>Antipattern</h4>
                    <pre>
let add = (x, y) => x + y;
let multiply = (x, y) => x * y;
let substract = (x, y) => x - y;
let result = substract(
                    multiply(
                            add(a, b), 
                    c),
        d)
                    </pre>
                    <p><b>This is antipattern because data flows in oposite direction that it reads</b>, so expression originaly is written last (most nested) must be executed first, 
                    where expression written first must be executed last</p></br>
                </br>
                <h4>Pattern</h4>
                <pre>
class Aritm{
constructor() {
    this.value = 0;
    this.array = [];
}
get val() {
    console.log('Returning: ' + this.value)
    return this.value;
}
set val(x) {
    console.log(x)
    this.value = x;
    return true;
}
add(x) {
    this.val = this.val + x;
    return this
}
substr(x) {
    this.val = this.val - x;
    return this;
}
multiply(x) {
    this.val = this.val * x;
    return this;
}
}

let a = new Aritm();
let b = a.add(2).add(3).multiply(3).substr(4).val;                        
                </pre>
                </div>

                <div class="hidable-wrapper">
                <div class="title"><div class="button button-hide">+</div><h3 id = "realChain">Chain of responsibilities</h3><a href="#home"><div class="button">Home</div></a></div>
                <div class="hidable">
                    <p>Chaining responsibilities is like a chain of callback functions. Some live examples are: event bubbling or (more js native) middleware in node.js</p>
                    <div class="note">
                        <p>Why is <code>next()</code> needed in node.js middleware? This example will explain:</p>
                        <div class="example">
                            <pre>
var app = require("express")();

app.get("/", function(httpRequest, httpResponse, next){
httpResponse.write("Hello");
next(); //remove this and see what happens 
});

app.get("/", function(httpRequest, httpResponse, next){
httpResponse.write(" World !!!");
httpResponse.end();
});

app.listen(8080);                                   
                            </pre>
                            <div class="explanation">
                                <p>In case there is only one match for every route, next will not be needed, as always first endpoint from the top will be served.
                                However in case of multiple matches, without <code>next()</code> call at the bottom, only first path will be matched. In example case
                                <b>only</b> <i>Hello</i> will be send.
                            </p>
                            <p>So thanks to <code>next()</code> next endpoints will be matched.</p>
                            </div>
                        </div> <!-- example-->
                    </div>

                    <p>Another simple example can be given: <a href="https://www.joezimjs.com/javascript/javascript-design-patterns-chain-of-responsibility/">ATM money stack</a></p>
                    <p>
                        ATM is a machine that pays You desired ammount of cash from Your account. Starting from the highest possible currencies to the smallest ones.
                    </p>
                    <ul>
                        <li>There is a sender, receiver and a request. </li>
                        <li>Sender (<code>this.moneyStacks = stack100</code> from ATM class) knows only about first receiver in the chain </li>
                        <li>Each reveiver knows about next receiver in the chain and sends processed request to next receiver</li>
                    </ul>
                    <div class="example">
                        <pre>
var MoneyStack = function(billSize) {
this.billSize = billSize;
this.next = null;
}
MoneyStack.prototype = {
withdraw: function(amount) {
    var numOfBills = Math.floor(amount / this.billSize);

    if (numOfBills > 0) {
        // Eject the bills
        this._ejectMoney(numOfBills);
        // Shrink the amount by how much money we ejected
        amount = amount - (this.billSize * numOfBills);
    }

    // If there is any money left to withdraw and if we have
    // another stack in the line, pass the request on
    amount > 0 && this.next && this.next.withdraw(amount);
},
// set the stack that comes next in the chain
setNextStack: function(stack) {
    this.next = stack;
},
// private method that ejects the money
_ejectMoney: function(numOfBills) {
    console.log(numOfBills + " $" + this.billSize
        + " bill(s) has/have been spit out");
}
}                                

var ATM = function() {
// Create the stacks of money
// We'll show you the implementation for this next
var stack100 = new MoneyStack(100),
    stack50 = new MoneyStack(50),
    stack20 = new MoneyStack(20),
    stack10 = new MoneyStack(10),
    stack5 = new MoneyStack(5),
    stack1 = new MoneyStack(1);

// Set the hierarchy for the stacks
stack100.setNextStack(stack50);
stack50.setNextStack(stack20);
stack20.setNextStack(stack10);
stack10.setNextStack(stack5);
stack5.setNextStack(stack1);

// Set the top stack as a property
this.moneyStacks = stack100;
}

ATM.prototype.withdraw = function(amount) {
this.moneyStacks.withdraw(amount);
}

// USAGE
var atm = new ATM();
atm.withdraw(186);
/* outputs:
1 $100 bill(s) has/have been spit out
1 $50 bill(s) has/have been spit out
1 $20 bill(s) has/have been spit out
1 $10 bill(s) has/have been spit out
1 $5 bill(s) has/have been spit out
1 $1 bill(s) has/have been spit out
*/
atm.withdraw(72);
/* outputs:
1 $50 bill(s) has/have been spit out
1 $20 bill(s) has/have been spit out
2 $1 bill(s) has/have been spit out
*/
                        </pre>
                    </div>

                </div> <!--hidable-->
            </div> <!--hidable wrapper for realChain-->

            </div>
            <!-- </div> -->
        </div><!--hidable-wrapper-->

        <div class="hidable-wrapper">
            <div class="title"><div class="button button-hide">+</div><h3 id = "command"><a href = "">Command</a></h3><a href="#home"><div class="button">Home</div></a></div>
            <div class="hidable" name="Command">`
                <ul>
                    <li><b>Client: </b> creates a command and uses a <b>invoker</b> manager that executes a command on receiver</li>
                    <li><b>Invoker: </b> a manager class used only to ivoke methods associated with commands</li>
                    <li><b>Receiver: </b> a class invoked by invoker. This class konws how to complete the task.</li>
                    <li>Used to encapsulete objects... Separate object make requests and those objects that invoke methods associated with those requests</li>
                    <li>Usefull when some code (receiver) might be changed. In that case change dosed not influence whole program.</li>
                    <li>Often used with <b>undo</b> and <b>redo</b> methods, history of executions is remembered</li>
                </ul>
                <div class="example">
                    <h4><a href="http://www.discoversdk.com/blog/learning-the-command-pattern-in-javascript">A general example:</a></h4>
                    <pre>
// Command Pattern
Tasker = (function(){
    var executor = {};
    var commands = {};
    executor.handle = function(commandName, callback){
        var commandHandler = {
            ref: this,
            callback: callback
        };
        commands[commandName] = commandHandler;
    };
    
    Tasker.execute = function(commandName, data){
        var cmd = commands[commandName];
        if (cmd){
            cmd.callback.call(cmd.ref, data);
        }
    };
    return executor;
})();

// Form
(function(Tasker){
    var btnSay = $("#sayit");
    var lblWord = $("#saythis");
    
    btnSay.click(function(e){
        e.preventDefault();
        Tasker.execute("doit", lblWord.val());
    });
})(Tasker);

(function(Tasker, $){
    var showTheText = function(data){
        var el = $("#showit");
        el.text("You told me to say: '" + data + "', so I did.");
    };
    
    // handle the command
    Tasker.handle("doit", showTheText);
})(Tasker, jQuery);                        
                    </pre>
                </div>

            </div>
        </div><!--hidable-->

        

    </div> <!--hidable-wrapper-->



    
    <div class="hidable-wrapper">
            <div class="title"><div class="button button-hide">+</div><h3 id = "uml"><a href="https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-class-diagram/">
                UML</a></h3><a href="#home"><div class="button">Home</div></a></div>
            <div class="hidable">

            <div class="hidable-wrapper">
                    <div class="title"><div class="button button-hide">+</div><h3 id = "classDiagram">Class diagram</h3><a href="#home"><div class="button">Home</div></a></div>
                    <div class="hidable">
                        <p>
                           <a href="https://www.samouczekprogramisty.pl/podstawy-uml/"> Descirbes classes and relations between classes</a>
                        </p>
                        <table class="uml">
                            <thead>
                                <tr>
                                    <th>ClassName</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>
                                        Atributes:
                                        <ul>
                                            <li>-private</li>
                                            <li>#protected</li>
                                            <li>+public</li>
                                            <li>-<u>static</u></li>
                                        </ul>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        Methods:
                                        <ul>
                                            <li>-private</li>
                                            <li>+public</li>
                                            <li>-<i>abstract</i> - this might refer to whole class</li>
                                        </ul>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <h4>Arrows:</h4>
                        <ul>
                            <li>It is a good habit to write relation types (names) above arrow (eg. spreadSheet <b>contains</b> cells, expression <b>evaluates to</b> value</p></li>
                            <li>a number on class side denotes a number of classes that may be in relation. Eg no number to 5 means that one instance may be in relation to 5 instancess</li>
                            <li>* on side of a class means realtion x to many. * on both classes means relation many to many</li>
                        </ul>
                        
                        <table>
                            <thead>
                                <tr>
                                    <th>Arrow</th>
                                    <th>Meaning</th>
                                    <th>Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>-----&#x25B7;</td>
                                    <td>Implementation: class implements an interface</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td><span style="position: relative; width: 2rem; overflow: hidden; display: inline-block; top:0.3rem;"><hr></span>&#x25B7;</td>
                                    <td>Inheritance. Parent class on the right in this case (parent is on arrowhead side)</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>-----></td>
                                    <td>
                                        Dependency
                                        <ul>
                                            <li>Class on the left depends on class on the right (not other way)</li>
                                            <li>Changes in left may cause changes in right (not the other way)</li>
                                        </ul>
                                    </td>
                                    <td>
                                        Window in relation to event
                                    </td>
                                </tr>
                                <tr>
                                    <td><span style="position: relative; width: 2rem; overflow: hidden; display: inline-block; top:0.3rem;"><hr></span>></td>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td><span style="position: relative; width: 2rem; overflow: hidden; display: inline-block; top:0.3rem;"><hr></span>&#x25C7;</td>
                                    <td>
                                        Aggregation - type of association:
                                        <ul>
                                            <li>Class on the left is a part of class on the right</li>
                                            <li>Separate lifetimes</li>
                                            <li>Many instances on the left - single instance on the right</li>
                                        </ul>

                                    </td>
                                    <td>
                                        <ul>
                                            <li>computer in relation to CPU, memory, mainboard</li>
                                            <li>CPU in relation to ALU, cache, program counter</li>
                                            <li>canvas in relation to shape</li>
                                        </ul>
                                    </td>
                                </tr>
                                <tr>
                                    <td><span style="position: relative; width: 2rem; overflow: hidden; display: inline-block; top:0.3rem;"><hr></span>&#x25C6;</td>
                                    <td>
                                        Composition:
                                        <ul>
                                            <li>Object of class on the left can live only if object on the right exists</li>
                                            <li>Special type of aggregation</li>
                                            <li>Relation one to many</li>
                                        </ul>
                                    </td>
                                    <td>
                                        Circle in relation to point
                                    </td>
                                </tr>
                                <tr>
                                    <td>------</td>
                                    <td>Comment - note</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td><span style="position: relative; width: 2rem; overflow: hidden; display: inline-block; top:0.3rem;"><hr></span></td>
                                    <td>
                                        Association:
                                        <ul>
                                            <li>Structural link between classes</li>
                                            <li>Classes know about each other</li>
                                        </ul>
                                    </td>
                                    <td>
                                        data controller in realtion to dialog box
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div><!--hidable-->
            </div><!--hidable-wrapper-->

            </div><!--hidable-->
    </div><!--hidable-wrapper-->


    <div class="hidable-wrapper">
        <div class="title"><div class="button button-hide">+</div><h3 id = "dictionary">Dictionary</h3><a href="#home"><div class="button">Home</div></a></div>
        <div class="hidable">
            <table class="sortable">
                <thead>
                    <tr>
                        <th>No</th>
                        <th>Phrase</th>
                        <th>Meaning</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>Abstract class</td>
                        <td>Class that cannot have a single instance. Purpose of this class is inheritance. This class may have only static methods or fields</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Static field/method</td>
                        <td>
                            A method that can be invoked on a class template, not on a instance. Eg: <span>class Person{}</span>, <span>let hans = new Person()</span>. In this case static metod can be invoked only on
                            Person, not on hans. Eg Person.getInstance(). Extending Person static methods set would be <span>Person.newStaticMethod()</span>. Extending instantialized methods set would be <span>
                                Person.prototype.newInstantializedMethod = funciotn(){}</span>
                        </td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Instantialized method/field</td>
                        <td>A method that can be invoked only on instance of class. Never on the whole class. This type of methods set would be extended with help of prototype. Eg
                            Person.prototype.newMethod = funciton() {}. Now invocation would be <span>let hans = new Person(); hans.newMethod()</span>
                        </td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Orthogonal method</td>
                        <td>Two ore more methods are <i>orthogonal</i> if they do not have any common methods or fields</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>association</td>
                        <td>Both classes know about each other</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div> <!--hidable-wrapper-->


    <div class="hidable-wrapper">
            <div class="title"><div class="button button-hide">+</div><h3 id = "commonErrors">Common errors</h3><a href="#home"><div class="button">Home</div></a></div>
            <div class="hidable">
                <table>
                    <thead>
                        <tr>
                            <th>Error</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Passing a class as data-attribute in HTML - bridge pattern</td>
                            <td>
<pre>

</pre>
                            </td>
                        </tr>
                        <tr>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td></td>
                        </tr>
                    </tbody>
                </table>
            </div>
    </div> <!--hidable-wrapper-->


</div> <!--wrapper-->

<div class="test-dupa" id = "test-d">


    </div>
</body>
<script>

    (function() {
    console.group('Links worth visithng');
        console.table({
            'Patterns good examples': 'https://www.joezimjs.com/javascript/javascript-design-patterns-chain-of-responsibility/'
        })
    console.groupEnd();
    })()
    window.addEventListener("DOMContentLoaded", (e) => {
        let hideAllHidable = () => {
            let allHidable = document.querySelectorAll('.hidable');
            let allHideButtons = document.querySelectorAll('.button-hide');
            for (let item of allHidable) {
                item.classList.add('hidden');
            }
            for (let button of allHideButtons){
                button.innerHTML = '+';
            }
        }
        let showAllHidable = () => {
            let allHidable = document.querySelectorAll('.hidable');
            let allHideButtons = document.querySelectorAll('.button-hide');
            for (let item of allHidable) {
                item.classList.remove('hidden');
            }
            for (let button of allHideButtons){
                button.innerHTML = '-';
            }
        }        
        let hideSingleHidable = (element) => {
            // element is a hidable wrapper class member. Takes first title member and first button hide member in title an attaches hide first hidable in it
            let title = element.querySelector('.title');
            let hideButton = title.querySelector('.button-hide');
            let hidable = element.querySelector('.hidable');
            let toggleState = (e) => {
                let isHidden = hideButton.innerHTML == '+'?true:false;
                if (isHidden) {
                    hideButton.innerHTML = '-';
                    hidable.classList.remove('hidden');
                } else {
                    hideButton.innerHTML = "+";
                    hidable.classList.add('hidden');
                }
            }
            hideButton.addEventListener('click', toggleState);
        }
        let allHidableWrappers = document.querySelectorAll('.hidable-wrapper');
        for (let item of allHidableWrappers) {
            hideSingleHidable(item);
        }
        hideAllHidable();
        let content = document.querySelector('.content');
        let a = content.querySelectorAll('a');
        for (let item of a) {
            item.addEventListener('click', (e) => {showAllHidable()})
        }

    })


</script>
</html>